(window.webpackJsonp=window.webpackJsonp||[]).push([[262],{658:function(e,r,l){"use strict";l.r(r);var o=l(27),s=Object(o.a)({},(function(){var e=this,r=e.$createElement,l=e._self._c||r;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h1",{attrs:{id:"准备使用-resourcebundle"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#准备使用-resourcebundle"}},[e._v("#")]),e._v(" 准备使用 ResourceBundle")]),e._v(" "),l("h2",{attrs:{id:"识别特定的对象"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#识别特定的对象"}},[e._v("#")]),e._v(" 识别特定的对象")]),e._v(" "),l("p",[e._v("如果你的程序有用户界面，那么包含许多的需要翻译的信息，包括下面可能的分类：")]),e._v(" "),l("ul",[l("li",[l("code",[e._v("String")]),e._v("：字符串")]),e._v(" "),l("li",[l("code",[e._v("Image")]),e._v("：图片")]),e._v(" "),l("li",[l("code",[e._v("Color")]),e._v("：颜色")]),e._v(" "),l("li",[l("code",[e._v("AudioClip")]),e._v("：音频")])]),e._v(" "),l("p",[e._v("您会注意到此列表不包含表示数字、日期、时间或货币的对象。这些对象的显示格式随 Locale 而异，但对象本身则不会有所不同。例如，根据 Locale  设置日期格式，但无论 Locale  如何，您都使用相同的 Date 对象。在 ResourceBundle 中隔离这些对象，而是使用特殊的 Locale  敏感格式类来设置它们格式。这些将在后续的 格式化 和 日期时间 章节学到这些")]),e._v(" "),l("p",[e._v("通常，存储在 ResourceBundle  中的对象是 "),l("strong",[e._v("预定义")]),e._v(" 的，并随着产品一起发货。程序运行时不会修改这些对象。例如，应在 ResourceBundle 中 "),l("strong",[e._v("存储菜单标签")]),e._v("，因为它特定于 Locale，在程序会话期间不会更改。但是，不应在 ResourceBundle  中隔离最终用户在文本字段中输入的字符串对象。此类字符串等数据可能因日而异。它特定于程序会话，而不是程序运行 Locale 。")]),e._v(" "),l("p",[e._v("通常，需要隔离在 ResourceBundle  中的对象 "),l("strong",[e._v("大多数是字符串对象")]),e._v("。但是，并非所有 String 对象都是特定于 Locale 的。例如，如果 String 是进程间通信使用的协议元素，则不需要本地化它，因为最终用户永远不会看到它。")]),e._v(" "),l("p",[e._v("是否本地化某些 String 对象的决定并不总是很清楚。日志文件是一个很好的例子。如果日志文件由一个程序编写并由另一个程序读取，则两个程序都使用日志文件作为通信缓冲区。假设最终用户偶尔会检查此日志文件的内容。日志文件不应该本地化吗？另一方面，如果最终用户很少检查日志文件，则翻译成本可能不值得。您决定本地化此日志文件取决于许多因素：程序设计、易用性、翻译成本和可支持性。")]),e._v(" "),l("h2",{attrs:{id:"组织-resourcebundle-对象"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#组织-resourcebundle-对象"}},[e._v("#")]),e._v(" 组织 ResourceBundle 对象")]),e._v(" "),l("p",[e._v("你可以根据你自己的业务将 ResourceBundle  进行分类，比如专门用一个 OrderLabelsBundle 来保存订单相关的信息，使用多个 ResourceBundle 有如下的优点：")]),e._v(" "),l("ul",[l("li",[e._v("代码更容易阅读和维护")]),e._v(" "),l("li",[e._v("避免巨大的 ResourceBundle 对象，因为太大的话，需要花费更多的时间加载到内存中")]),e._v(" "),l("li",[e._v("可以根据需要加载指定的  ResourceBundle ，减少内存的使用")])])])}),[],!1,null,null,null);r.default=s.exports}}]);